<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Super Mario Platformer</title>
  <style>
    :root {
      --bg1: #5c94fc;
      --bg2: #b4e2ff;
      --panel: rgba(0, 0, 0, .2);
      --panel2: rgba(255, 255, 255, .1);
      --fg: #ffffff;
      --muted: rgba(255, 255, 255, .8);
      --accent: #ffdb15;
      --danger: #ff3c3c;
      --good: #2de38c;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      margin: 0;
      min-height: 100vh;
      min-height: 100dvh;
      /* Mobile viewport fix */
      font-family: system-ui, Segoe UI, Arial;
      color: var(--fg);
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow: hidden;
      /* Mobile Polish: Prevent selection, scrolling, and zooming */
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }

    .wrap {
      width: min(1100px, 100%);
      margin: 0 auto;
      padding: 14px;
    }

    .topbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .pill {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .14);
      padding: 8px 12px;
      border-radius: 999px;
      display: flex;
      gap: 14px;
      align-items: center;
      backdrop-filter: blur(10px);
    }

    .pill b {
      color: #fff;
    }

    .btns {
      display: flex;
      gap: 10px;
    }

    button {
      cursor: pointer;
      color: var(--fg);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, .14);
      padding: 9px 12px;
      border-radius: 12px;
      transition: transform .06s ease, border-color .15s ease;
      backdrop-filter: blur(10px);
      /* Mobile Polish */
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }

    button:hover {
      border-color: rgba(255, 255, 255, .25);
    }

    button:active {
      transform: scale(.98);
    }

    canvas {
      width: 100%;
      height: auto;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, .14);
      background: linear-gradient(180deg, rgba(255, 255, 255, .03), rgba(0, 0, 0, .10));
      box-shadow: 0 18px 60px rgba(0, 0, 0, .45);
      display: block;
    }

    .help {
      margin-top: 10px;
      font-size: 14px;
      color: var(--muted);
      line-height: 1.35;
    }

    /* Overlay screens (menu / pause / win / gameover) */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0, 0, 0, .65);
      backdrop-filter: blur(8px);
      padding: 16px;
      z-index: 10;
      animation: fadeIn 0.2s ease-out;
    }

    .card {
      width: min(600px, 95%);
      /* "Nintendo Blue" Style: Bright, friendly, toy-like */
      background: linear-gradient(180deg, #5b99ff, #256cdf);
      border: 4px solid #fff;
      border-radius: 16px;
      padding: 24px;
      box-shadow:
        0 8px 0 rgba(0, 0, 0, 0.2),
        /* "3D" edge */
        0 20px 40px rgba(0, 0, 0, 0.4);
      text-align: center;
      color: #fff;
      animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    @keyframes popIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .card h1 {
      margin: 0 0 16px 0;
      font-size: 32px;
      color: #fff;
      text-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
      font-weight: 800;
      letter-spacing: 0.5px;
    }

    .card p {
      margin: 8px 0 28px;
      color: rgba(255, 255, 255, 0.95);
      font-size: 17px;
      line-height: 1.4;
      font-weight: 500;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    /* Button Variants */
    .btn-primary {
      background: linear-gradient(180deg, #ffce00, #eeb200);
      /* Mario Coin Gold */
      color: #7b4900;
      border: 2px solid #fff;
      font-weight: 800;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      text-transform: uppercase;
      font-size: 14px;
      letter-spacing: 0.5px;
    }

    .btn-primary:hover {
      background: linear-gradient(180deg, #ffd933, #ffce00);
      transform: translateY(-2px);
      box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
    }

    .btn-secondary {
      background: rgba(0, 0, 0, 0.2);
      border: 2px solid transparent;
      color: #fff;
      font-weight: 600;
    }

    .btn-secondary:hover {
      background: rgba(0, 0, 0, 0.3);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .levelBtn {
      text-align: left;
      padding: 12px;
      border-radius: 14px;
      background: rgba(255, 255, 255, .06);
      border: 1px solid rgba(255, 255, 255, .14);
    }

    .levelBtn.locked {
      opacity: .55;
      cursor: not-allowed;
    }

    .levelBtn .tag {
      display: inline-block;
      margin-top: 8px;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .08);
      border: 1px solid rgba(255, 255, 255, .14);
    }

    /* Mobile touch controls */
    .touch {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 12px;
      display: none;
      justify-content: space-between;
      gap: 12px;
      padding: 0 12px;
      z-index: 9;
      pointer-events: none;
    }

    .touch .cluster {
      display: flex;
      gap: 12px;
      pointer-events: auto;
    }

    .touch button {
      width: 64px;
      height: 64px;
      border-radius: 18px;
      font-size: 20px;
      background: rgba(255, 255, 255, .10);
    }

    @media (max-width: 1366px),
    (pointer: coarse) {
      .touch {
        display: flex;
      }
    }

    canvas:fullscreen,
    .wrap:fullscreen canvas {
      border-radius: 0;
      border: none;
      height: 100vh;
      width: auto;
      margin: 0 auto;
    }

    .wrap:fullscreen {
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      /* Center content */
      background: var(--bg1);
    }

    .wrap:fullscreen .topbar {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 100;
    }

    .wrap:fullscreen .help {
      display: none;
    }

    .wrap:fullscreen .overlay {
      position: absolute;
      /* Needed for full-screen centering */
      z-index: 200;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="pill">
        <span>Level: <b id="uiLevel">1</b></span>
        <span>Score: <b id="uiScore">000000</b></span>
        <span>Coins: <b id="uiCoins">0</b></span>
        <span>Lives: <b id="uiLives">3</b></span>
        <span>Time: <b id="uiTime">400</b></span>
        <span>High: <b id="uiHigh">000000</b></span>
      </div>
      <div class="btns">
        <button id="btnMenu">Menu</button>
        <button id="btnRestart">Restart</button>
        <button id="btnPause">Pause</button>
        <button id="btnFull">Full Screen</button>
        <button id="btnMute">Unmute</button>
      </div>
    </div>

    <canvas id="c" width="1000" height="560"></canvas>

    <div class="help">
      Controls: <b>← →</b> move, <b>Space / ↑</b> jump, <b>Esc</b> pause. <br />
      Mobile: use on-screen buttons. Touch the checkpoint marker to set respawn.
    </div>

    <!-- Overlays inside wrap for Full Screen support -->
    <div class="overlay" id="overlayMenu">
      <div class="card">
        <h1>Super Mario Platformer</h1>
        <p>Pick a level. Finish a level to unlock the next. Your high score is saved locally.</p>
        <div class="grid" id="levelGrid"></div>
        <div style="display:flex; gap:12px; margin-top:24px; justify-content:center; flex-wrap:wrap;">
          <button id="btnResumeFromMenu" class="btn-primary">Resume</button>
          <button id="btnResetProgress" class="btn-secondary">Reset Progress</button>
        </div>
        <p style="margin-top:10px; font-size:13px;">Assets: <b>player.png</b> and <b>enemy.png</b> should be present.
        </p>
      </div>
    </div>

    <div class="overlay" id="overlayMsg">
      <div class="card">
        <h1 id="msgTitle">Paused</h1>
        <p id="msgBody">—</p>
        <div style="display:flex; gap:10px; margin-top:14px; flex-wrap:wrap;">
          <button id="msgPrimary">Continue</button>
          <button id="msgSecondary">Menu</button>
        </div>
      </div>
    </div>

    <!-- Touch controls -->
    <div class="touch" id="touch">
      <div class="cluster">
        <button id="tLeft">◀</button>
        <button id="tRight">▶</button>
      </div>
      <div class="cluster">
        <button id="tJump">⤒</button>
      </div>
    </div>
  </div>



  <script>
    (() => {
      // ==========================
      // UI
      // ==========================
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');

      const UI = {
        level: document.getElementById('uiLevel'),
        score: document.getElementById('uiScore'),
        coins: document.getElementById('uiCoins'),
        lives: document.getElementById('uiLives'),
        high: document.getElementById('uiHigh'),
        btnMenu: document.getElementById('btnMenu'),
        btnRestart: document.getElementById('btnRestart'),
        btnPause: document.getElementById('btnPause'),
        overlayMenu: document.getElementById('overlayMenu'),
        levelGrid: document.getElementById('levelGrid'),
        btnResumeFromMenu: document.getElementById('btnResumeFromMenu'),
        btnResetProgress: document.getElementById('btnResetProgress'),
        overlayMsg: document.getElementById('overlayMsg'),
        msgTitle: document.getElementById('msgTitle'),
        msgBody: document.getElementById('msgBody'),
        msgPrimary: document.getElementById('msgPrimary'),
        msgSecondary: document.getElementById('msgSecondary'),
        btnFull: document.getElementById('btnFull'),
        btnMute: document.getElementById('btnMute'),
        time: document.getElementById('uiTime'),
        touch: document.getElementById('touch'),
        tLeft: document.getElementById('tLeft'),
        tRight: document.getElementById('tRight'),
        tJump: document.getElementById('tJump'),
      };

      // ==========================
      // STORAGE
      // ==========================
      const LS = {
        unlocked: "mario_platformer_unlocked",
        high: "mario_platformer_high"
      };
      const getUnlocked = () => Number(localStorage.getItem(LS.unlocked) || "1");
      const setUnlocked = (n) => localStorage.setItem(LS.unlocked, String(n));
      const getHigh = () => Number(localStorage.getItem(LS.high) || "0");
      const setHigh = (n) => localStorage.setItem(LS.high, String(n));

      // ==========================
      // INPUT
      // ==========================
      const keys = new Set();
      const press = (code) => keys.add(code);
      const release = (code) => keys.delete(code);

      addEventListener('keydown', (e) => {
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "Space", "Escape"].includes(e.code)) e.preventDefault();
        if (e.code === "Escape") togglePause();
        keys.add(e.code);
      }, { passive: false });

      addEventListener('keyup', (e) => keys.delete(e.code));

      // Touch buttons map to keyboard codes
      const bindTouch = (btn, code) => {
        const down = (e) => { e.preventDefault(); press(code); };
        const up = (e) => { e.preventDefault(); release(code); };
        btn.addEventListener('pointerdown', down, { passive: false });
        btn.addEventListener('pointerup', up, { passive: false });
        btn.addEventListener('pointercancel', up, { passive: false });
        btn.addEventListener('pointerleave', up, { passive: false });
      };
      bindTouch(UI.tLeft, "ArrowLeft");
      bindTouch(UI.tRight, "ArrowRight");
      bindTouch(UI.tJump, "Space");

      // ==========================
      // MOBILE POLISH HANDLERS
      // ==========================
      // Prevent long-press context menu
      window.addEventListener('contextmenu', (e) => {
        e.preventDefault();
      }, { passive: false });

      // Prevent potential elastic scrolling / pull-to-refresh
      document.addEventListener('touchmove', (e) => {
        e.preventDefault();
      }, { passive: false });

      // ==========================
      // UTILITIES
      // ==========================
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const fmtScore = (n) => String(Math.floor(n)).padStart(6, '0');

      const aabb = (A, B) =>
        A.x < B.x + B.w && A.x + A.w > B.x &&
        A.y < B.y + B.h && A.y + A.h > B.y;

      const roundedRect = (x, y, w, h, r) => {
        r = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      };

      // ==========================
      // ASSET: MATLAB ICON
      // ==========================
      const playerImg = new Image();
      playerImg.src = "player.png";
      let imgReady = false;
      playerImg.onload = () => imgReady = true;
      playerImg.onerror = () => {
        console.warn("Player image failed to load, using fallback.");
        imgReady = false;
      };

      const enemyImg = new Image();
      enemyImg.src = "enemy.png";
      let enemyImgReady = false;
      enemyImg.onload = () => enemyImgReady = true;
      enemyImg.onerror = () => enemyImgReady = false;

      // ==========================
      // GAME STATE
      // ==========================
      let state = "menu"; // menu, playing, paused, message
      let currentLevelIndex = 0;

      let score = 0;
      let scoreAtLevelStart = 0;
      let coinsCollected = 0;
      let lives = 3;

      let cameraX = 0;
      let cameraY = 0;

      // Physics tune (feels "Mario-like" without copying anything)
      const physics = {
        gravity: 2100,
        moveAcc: 2900,
        maxSpeed: 380,
        jumpVel: 800,

        frictionGround: 0.82,
        frictionAir: 0.93,

        // Quality-of-life (big upgrade)
        coyoteTime: 0.09,      // jump allowed shortly after leaving ground
        jumpBuffer: 0.11       // jump pressed slightly early will still trigger
      };

      // Player
      const player = {
        x: 0, y: 0, w: 60, h: 60,
        vx: 0, vy: 0,
        facing: 1,
        onGround: false,
        coyote: 0,
        jumpQueued: 0,
        invuln: 0, // seconds of invulnerability after hit
      };

      // World objects (per level)
      let world = null;

      // ==========================
      // LEVELS
      // ==========================
      // Neutral visuals: platforms, spikes, coins, enemies, checkpoint, goal.
      // You can add/edit levels by modifying these definitions.
      const levels = [
        {
          name: "Level 1 - Intro",
          width: 2400,
          height: canvas.height,
          spawn: { x: 80, y: 200 },
          goal: { x: 2280, y: 430, w: 60, h: 60 },
          checkpoint: { x: 1200, y: 420, w: 34, h: 70 },
          platforms: [
            { x: 0, y: 500, w: 2400, h: 60 },
            { x: 220, y: 420, w: 160, h: 22 },
            { x: 470, y: 370, w: 180, h: 22 },
            { x: 750, y: 330, w: 150, h: 22 },
            { x: 1000, y: 390, w: 220, h: 22 },
            { x: 1320, y: 340, w: 180, h: 22 },
            { x: 1620, y: 290, w: 200, h: 22 },
            { x: 1920, y: 360, w: 220, h: 22 },
          ],
          movingPlatforms: [
            // rideable, oscillating platform
            { x1: 1460, y1: 440, x2: 1700, y2: 440, w: 110, h: 18, t: 0, speed: 0.55 }
          ],
          spikes: [
            { x: 640, y: 480, w: 90, h: 20 },
            { x: 1180, y: 480, w: 90, h: 20 },
            { x: 2050, y: 480, w: 120, h: 20 },
          ],
          coins: [
            { x: 260, y: 380 }, { x: 530, y: 330 }, { x: 790, y: 290 }, { x: 1040, y: 350 }, { x: 1350, y: 300 },
            { x: 1660, y: 250 }, { x: 1930, y: 320 }, { x: 2100, y: 450 }, { x: 900, y: 460 }
          ],
          enemies: [
            { x: 880, y: 450, w: 50, h: 50, vx: 70, minX: 820, maxX: 1040, alive: true },
            { x: 1750, y: 450, w: 50, h: 50, vx: 80, minX: 1720, maxX: 1880, alive: true }
          ]
        },
        {
          name: "Level 2 - Moving Platforms",
          width: 2700,
          height: canvas.height,
          spawn: { x: 80, y: 200 },
          goal: { x: 2550, y: 420, w: 60, h: 60 },
          checkpoint: { x: 1450, y: 420, w: 34, h: 70 },
          platforms: [
            { x: 0, y: 500, w: 2700, h: 60 },
            { x: 260, y: 420, w: 170, h: 22 },
            { x: 560, y: 360, w: 180, h: 22 },
            { x: 860, y: 410, w: 160, h: 22 },
            { x: 1180, y: 340, w: 200, h: 22 },
            { x: 1760, y: 320, w: 220, h: 22 },
            { x: 2100, y: 380, w: 200, h: 22 },
          ],
          movingPlatforms: [
            { x1: 980, y1: 280, x2: 1300, y2: 280, w: 120, h: 18, t: 0, speed: 0.75 },
            { x1: 1500, y1: 420, x2: 1500, y2: 260, w: 120, h: 18, t: 0, speed: 0.60 },
            { x1: 2000, y1: 260, x2: 2300, y2: 260, w: 110, h: 18, t: 0, speed: 0.75 }
          ],
          spikes: [
            { x: 700, y: 480, w: 120, h: 20 },
            { x: 1520, y: 480, w: 120, h: 20 },
            { x: 2200, y: 480, w: 160, h: 20 },
          ],
          coins: [
            { x: 290, y: 380 }, { x: 590, y: 320 }, { x: 900, y: 370 }, { x: 1210, y: 300 },
            { x: 1560, y: 220 }, { x: 1780, y: 280 }, { x: 2140, y: 340 }, { x: 2340, y: 220 }, { x: 2460, y: 460 }
          ],
          enemies: [
            { x: 430, y: 450, w: 50, h: 50, vx: 85, minX: 260, maxX: 560, alive: true },
            { x: 1900, y: 450, w: 50, h: 50, vx: 95, minX: 1820, maxX: 2080, alive: true },
          ]
        },
        {
          name: "Level 3 - Challenge",
          width: 3000,
          height: canvas.height,
          spawn: { x: 80, y: 200 },
          goal: { x: 2850, y: 420, w: 60, h: 60 },
          checkpoint: { x: 1650, y: 420, w: 34, h: 70 },
          platforms: [
            { x: 0, y: 500, w: 3000, h: 60 },
            { x: 260, y: 420, w: 160, h: 22 },
            { x: 520, y: 360, w: 160, h: 22 },
            { x: 780, y: 300, w: 160, h: 22 },
            { x: 1040, y: 360, w: 160, h: 22 },
            { x: 1300, y: 420, w: 160, h: 22 },
            { x: 1900, y: 350, w: 220, h: 22 },
            { x: 2260, y: 300, w: 170, h: 22 },
            { x: 2520, y: 360, w: 170, h: 22 },
          ],
          movingPlatforms: [
            { x1: 1500, y1: 440, x2: 1800, y2: 260, w: 120, h: 18, t: 0, speed: 0.55 },
            { x1: 2100, y1: 440, x2: 2400, y2: 440, w: 120, h: 18, t: 0, speed: 0.80 },
          ],
          spikes: [
            { x: 630, y: 480, w: 140, h: 20 },
            { x: 1460, y: 480, w: 160, h: 20 },
            { x: 2060, y: 480, w: 160, h: 20 },
            { x: 2620, y: 480, w: 160, h: 20 },
          ],
          coins: [
            { x: 290, y: 380 }, { x: 550, y: 320 }, { x: 810, y: 260 }, { x: 1070, y: 320 }, { x: 1330, y: 380 },
            { x: 1540, y: 220 }, { x: 1970, y: 310 }, { x: 2310, y: 260 }, { x: 2560, y: 320 }, { x: 2760, y: 460 }
          ],
          enemies: [
            { x: 980, y: 450, w: 50, h: 50, vx: 110, minX: 910, maxX: 1180, alive: true },
            { x: 2060, y: 450, w: 50, h: 50, vx: 120, minX: 1940, maxX: 2160, alive: true },
            { x: 2700, y: 450, w: 50, h: 50, vx: 130, minX: 2620, maxX: 2860, alive: true },
          ]
        }
      ];

      // ==========================
      // BUILD WORLD FROM LEVEL
      // ==========================
      function loadLevel(index) {
        currentLevelIndex = index;
        const L = levels[index];

        world = {
          name: L.name,
          width: L.width,
          height: L.height,

          platforms: L.platforms.map(p => ({ ...p })),
          movingPlatforms: (L.movingPlatforms || []).map(p => ({ ...p, x: p.x1, y: p.y1, lastX: p.x1, lastY: p.y1 })),
          spikes: (L.spikes || []).map(s => ({ ...s })),
          enemies: (L.enemies || []).map(e => ({ ...e })),
          checkpoint: { ...L.checkpoint },
          goal: { ...L.goal },

          coins: (L.coins || []).map(c => ({ x: c.x, y: c.y, w: 18, h: 18, taken: false })),

          // respawn point starts at spawn; updates when checkpoint touched
          respawn: { x: L.spawn.x, y: L.spawn.y },

          timeLeft: 400,
        };

        // reset player
        player.x = L.spawn.x;
        player.y = L.spawn.y;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        player.coyote = 0;
        player.jumpQueued = 0;
        player.invuln = 0;
        player.facing = 1;

        // camera
        cameraX = 0;
        cameraY = 0;

        // per-level counters (score continues overall; coins per run)
        coinsCollected = 0;

        // UI
        UI.level.textContent = (index + 1);
        UI.coins.textContent = coinsCollected;
        UI.score.textContent = fmtScore(score);
        UI.lives.textContent = lives;
        UI.time.textContent = Math.floor(world.timeLeft);
        UI.high.textContent = fmtScore(getHigh());

        // Remember score at start of level for "Restart Level"
        scoreAtLevelStart = score;
      }

      // ==========================
      // MENU BUILD
      // ==========================
      function buildMenu() {
        UI.levelGrid.innerHTML = "";
        const unlocked = getUnlocked();

        levels.forEach((L, i) => {
          const btn = document.createElement("button");
          btn.className = "levelBtn" + (i + 1 <= unlocked ? "" : " locked");
          btn.innerHTML = `
        <div style="font-weight:700;">Level ${i + 1}</div>
        <div style="opacity:.8; font-size:12px; margin-top:4px;">${L.name}</div>
        <div class="tag">${i + 1 <= unlocked ? "Unlocked" : "Locked"}</div>
      `;
          if (i + 1 <= unlocked) {
            btn.onclick = () => {
              hideMenu();
              startGame(i);
            };
          }
          UI.levelGrid.appendChild(btn);
        });
      }

      function showMenu() {
        state = "menu";
        paused = true;
        buildMenu();
        UI.overlayMenu.style.display = "grid";
      }
      function hideMenu() {
        UI.overlayMenu.style.display = "none";
      }

      // ==========================
      // MESSAGE OVERLAY
      // ==========================
      function showMessage(title, body, primaryText, primaryFn, secondaryText, secondaryFn) {
        state = "message";
        paused = true;
        UI.msgTitle.textContent = title;
        UI.msgBody.textContent = body;
        UI.msgPrimary.textContent = primaryText;
        UI.msgPrimary.className = "btn-primary";
        UI.msgSecondary.textContent = secondaryText;
        UI.msgSecondary.className = "btn-secondary";

        UI.msgPrimary.onclick = () => { UI.overlayMsg.style.display = "none"; primaryFn?.(); };
        UI.msgSecondary.onclick = () => { UI.overlayMsg.style.display = "none"; secondaryFn?.(); };

        UI.overlayMsg.style.display = "grid";
      }

      // ==========================
      // BUTTONS
      // ==========================
      let paused = false;

      function togglePause() {
        if (state === "menu") return;
        paused = !paused;
        UI.btnPause.textContent = paused ? "Resume" : "Pause";

        if (paused) {
          showMessage("Paused", "Take a break. Resume when ready.",
            "Continue", () => { paused = false; state = "playing"; UI.btnPause.textContent = "Pause"; last = performance.now(); },
            "Menu", () => showMenu()
          );
        }
      }

      UI.btnPause.onclick = togglePause;
      UI.btnRestart.onclick = () => startGame(currentLevelIndex);
      UI.btnMenu.onclick = () => showMenu();

      UI.btnFull.onclick = () => {
        const wrap = document.querySelector('.wrap');
        if (!document.fullscreenElement) {
          wrap.requestFullscreen().catch(err => {
            console.error(`Error attempting to enable full-screen mode: ${err.message}`);
          });
        } else {
          document.exitFullscreen();
        }
      };

      UI.btnMute.onclick = () => {
        const muted = AudioEngine.toggleMute();
        UI.btnMute.textContent = muted ? "Unmute" : "Mute";
        // Also ensure context is running if they clicked mute first thing
        AudioEngine.init();
      };

      document.addEventListener('fullscreenchange', () => {
        UI.btnFull.textContent = document.fullscreenElement ? "Exit Full" : "Full Screen";
        handleResize(); // Trigger resize on toggle
      });

      // ==========================
      // VIEWPORT / RESIZE HANDLER
      // ==========================
      function handleResize() {
        const wrap = document.querySelector('.wrap');
        const isFull = !!document.fullscreenElement;

        let availableWidth, availableHeight;

        if (isFull) {
          availableWidth = window.innerWidth;
          availableHeight = window.innerHeight;
        } else {
          // Not fullscreen: respect the wrap's normal layout
          // But since the wrap is responsive, we look at the viewport or container?
          // Actually, let's just make the canvas responsive in the flow.
          // Since .wrap has a max-width of 1100px or 100%, we fit inside that.
          // However, to fix "layout breaks", we really want to just ensure the canvas fits.

          // We'll trust CSS for non-fullscreen usually, BUT to prevent clipped UI
          // let's just ensure standard responsiveness.
          canvas.style.width = '100%';
          canvas.style.height = 'auto';
          return;
        }

        // Fullscreen Logic: Letterboxing
        const targetRatio = 1000 / 560; // 1.78
        const winRatio = availableWidth / availableHeight;

        let w, h;
        if (winRatio > targetRatio) {
          // Window is wider than game -> limit by height
          h = availableHeight;
          w = h * targetRatio;
        } else {
          // Window is taller than game -> limit by width
          w = availableWidth;
          h = w / targetRatio;
        }

        canvas.style.width = `${w}px`;
        canvas.style.height = `${h}px`;
        canvas.style.flex = "none"; // Stop flex from messing with size
      }

      window.addEventListener('resize', handleResize);
      // Initial call
      handleResize();

      UI.btnResumeFromMenu.onclick = () => {
        UI.overlayMenu.style.display = "none";
        if (world) { paused = false; state = "playing"; UI.btnPause.textContent = "Pause"; last = performance.now(); }
      };

      UI.btnResetProgress.onclick = () => {
        localStorage.removeItem(LS.unlocked);
        localStorage.removeItem(LS.high);
        score = 0;
        lives = 3;
        buildMenu();
        UI.high.textContent = "0";
        UI.score.textContent = "0";
        UI.lives.textContent = "3";
      };

      // ==========================
      // MUSIC SYSTEM (Web Audio API)
      // ==========================
      const AudioEngine = (() => {
        let ctx = null;
        let masterGain = null;
        let isMuted = true;

        const NOTES = {
          B0: 30.87, C1: 32.70, D1: 36.71, E1: 41.20, F1: 43.65, G1: 49.00, A1: 55.00, B1: 61.74,
          C2: 65.41, D2: 73.42, E2: 82.41, F2: 87.31, G2: 98.00, A2: 110.00, B2: 123.47,
          C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196.00, A3: 220.00, B3: 246.94,
          C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88,
          C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99, A5: 880.00, B5: 987.77,
          C6: 1046.50, D6: 1174.66, E6: 1318.51, F6: 1396.91, G6: 1567.98, A6: 1760.00, B6: 1975.53
        };

        // Simplified Mario Overworld Theme (Key of C)
        // [Note, Duration (1.0 = beat)]
        // Tempo ~ 100bpm => 600ms per beat? Mario is fast, let's say 150ms per 16th note.
        // We'll use a tick system.
        const marioTheme = [
          // Intro
          ['E5', 0.15], ['E5', 0.30], ['E5', 0.30], ['C5', 0.15], ['E5', 0.30], ['G5', 0.60], ['G4', 0.60],
          // Theme A
          ['C5', 0.45], ['G4', 0.45], ['E4', 0.45], ['A4', 0.30], ['B4', 0.30], ['A#4', 0.15], ['A4', 0.30],
          ['G4', 0.20], ['E5', 0.20], ['G5', 0.20], ['A5', 0.30], ['F5', 0.15], ['G5', 0.30],
          ['E5', 0.30], ['C5', 0.15], ['D5', 0.15], ['B4', 0.30],
          // Repeat A slightly diff
          ['C5', 0.45], ['G4', 0.45], ['E4', 0.45], ['A4', 0.30], ['B4', 0.30], ['A#4', 0.15], ['A4', 0.30],
          ['G4', 0.20], ['E5', 0.20], ['G5', 0.20], ['A5', 0.30], ['F5', 0.15], ['G5', 0.30],
          ['E5', 0.30], ['C5', 0.15], ['D5', 0.15], ['B4', 0.30]
        ];

        let noteIndex = 0;
        let nextNoteTime = 0;
        let isPlaying = false;

        function init() {
          if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.10; // Low volume so it's not annoying
            masterGain.connect(ctx.destination);
          }
          if (ctx.state === 'suspended') {
            ctx.resume();
          }
        }

        function playTone(freq, duration) {
          if (!ctx || isMuted) return;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();

          osc.type = 'square'; // NES style
          osc.frequency.setValueAtTime(freq, ctx.currentTime);

          // Envelope: Attack (fast), Decay
          gain.gain.setValueAtTime(0.01, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(masterGain.gain.value, ctx.currentTime + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration - 0.02);

          osc.connect(gain);
          gain.connect(ctx.destination);

          osc.start();
          osc.stop(ctx.currentTime + duration);
        }

        function update(dt) {
          if (!isPlaying || !ctx) return;

          if (ctx.currentTime >= nextNoteTime) {
            const [note, dur] = marioTheme[noteIndex];
            const freq = NOTES[note];
            if (freq) {
              playTone(freq, dur * 0.9); // Staccato
            }
            // Advance
            nextNoteTime = ctx.currentTime + dur;
            noteIndex = (noteIndex + 1) % marioTheme.length;
          }
        }

        function playJump() {
          if (!ctx || isMuted) return;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'square';
          osc.frequency.setValueAtTime(150, ctx.currentTime);
          osc.frequency.linearRampToValueAtTime(300, ctx.currentTime + 0.1);
          gain.gain.setValueAtTime(0.1, ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + 0.1);
        }

        function playCoin() {
          if (!ctx || isMuted) return;
          const t = ctx.currentTime;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'square';
          osc.frequency.setValueAtTime(988, t);
          osc.frequency.setValueAtTime(1319, t + 0.08);
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.3);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start();
          osc.stop(t + 0.3);
        }

        function playStomp() {
          if (!ctx || isMuted) return;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.1);
          gain.gain.setValueAtTime(0.15, ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + 0.1);
        }

        function playDamage() {
          if (!ctx || isMuted) return;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(400, ctx.currentTime);
          osc.frequency.linearRampToValueAtTime(50, ctx.currentTime + 0.3);
          gain.gain.setValueAtTime(0.15, ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + 0.3);
        }

        function playWin() {
          if (!ctx || isMuted) return;
          // Stop main music loop temporarily if you wanted (but we have separate tracks/logic).
          // Ideally we pause music? For now just overlay.
          isPlaying = false; // Stop BGM

          const now = ctx.currentTime;
          const tones = [
            [523.25, 0.10], // C
            [523.25, 0.10], // C
            [523.25, 0.10], // C
            [659.25, 0.30], // E
            [783.99, 0.30], // G
            [1046.50, 0.60]  // C6
          ];
          let t = now;
          tones.forEach(([freq, dur]) => {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle'; // Smoother for victory
            osc.frequency.setValueAtTime(freq, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + dur);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
            t += dur * 0.9;
          });
        }

        function playGameOver() {
          if (!ctx || isMuted) return;
          isPlaying = false; // Stop BGM
          const now = ctx.currentTime;
          const tones = [
            [523.25, 0.2], // C
            [493.88, 0.2], // B
            [466.16, 0.2], // Bb
            [440.00, 0.6]  // A
          ];
          let t = now;
          tones.forEach(([freq, dur]) => {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(freq, t);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.linearRampToValueAtTime(0, t + dur);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
            t += dur;
          });
        }

        return {
          init,
          start: () => { init(); isPlaying = true; nextNoteTime = ctx ? ctx.currentTime : 0; noteIndex = 0; },
          stop: () => { isPlaying = false; },
          update,
          toggleMute: () => { isMuted = !isMuted; return isMuted; },
          playJump,
          playCoin,
          playStomp,
          playDamage,
          playWin,
          playGameOver
        };
      })();

      // START / RESTART / RESPAWN
      // ==========================
      function startGame(levelIndex) {
        if (!localStorage.getItem(LS.unlocked)) setUnlocked(1);
        if (!localStorage.getItem(LS.high)) setHigh(0);

        lives = 3;
        score = 0;
        UI.lives.textContent = lives;
        UI.score.textContent = score;
        UI.high.textContent = getHigh();

        loadLevel(levelIndex);
        paused = false;
        state = "playing";
        UI.btnPause.textContent = "Pause";
        last = performance.now();
        AudioEngine.start();
      }

      function restartLevel() {
        // revert to score at level start
        score = scoreAtLevelStart;
        const L = levels[currentLevelIndex];
        world.respawn.x = L.spawn.x;
        world.respawn.y = L.spawn.y;
        loadLevel(currentLevelIndex);
        paused = false;
        state = "playing";
        UI.btnPause.textContent = "Pause";
        last = performance.now();
      }

      function respawn() {
        player.x = world.respawn.x;
        player.y = world.respawn.y;
        player.vx = 0; player.vy = 0;
        player.onGround = false;
        player.coyote = 0;
        player.jumpQueued = 0;
        player.invuln = 1.2; // invulnerability after respawn
      }

      function loseLife(reason) {
        lives--;
        UI.lives.textContent = lives;

        if (lives <= 0) {
          AudioEngine.playGameOver();
          const high = getHigh();
          if (score > high) setHigh(Math.floor(score));
          UI.high.textContent = fmtScore(getHigh());

          showMessage("Game Over", `Score: ${fmtScore(score)}. ${reason || ""}`.trim(),
            "Restart", () => startGame(0),
            "Menu", () => showMenu()
          );
        } else {
          AudioEngine.playDamage();
          showMessage("Ouch!", `Lives left: ${lives}.`,
            "Continue", () => { paused = false; state = "playing"; UI.btnPause.textContent = "Pause"; respawn(); last = performance.now(); },
            "Restart Level", () => restartLevel()
          );
        }
      }

      // ==========================
      // MOVING PLATFORMS UPDATE
      // ==========================
      function updateMovingPlatforms(dt) {
        for (const p of world.movingPlatforms) {
          p.lastX = p.x; p.lastY = p.y;
          p.t += dt * p.speed;

          // smooth oscillation between endpoints
          const s = (Math.sin(p.t * Math.PI * 2) + 1) / 2; // 0..1
          p.x = lerp(p.x1, p.x2, s);
          p.y = lerp(p.y1, p.y2, s);
          p.dx = p.x - p.lastX;
          p.dy = p.y - p.lastY;
        }
      }

      // ==========================
      // COLLISION & PHYSICS
      // ==========================
      function resolvePlatformsX(entity, plats) {
        for (const p of plats) {
          if (!aabb(entity, p)) continue;
          if (entity.vx > 0) entity.x = p.x - entity.w;
          else if (entity.vx < 0) entity.x = p.x + p.w;
          entity.vx = 0;
        }
      }

      function resolvePlatformsY(entity, plats) {
        let landedOn = null;
        for (const p of plats) {
          if (!aabb(entity, p)) continue;
          if (entity.vy > 0) {
            entity.y = p.y - entity.h;
            entity.vy = 0;
            entity.onGround = true;
            landedOn = p;
          } else if (entity.vy < 0) {
            entity.y = p.y + p.h;
            entity.vy = 0;
          }
        }
        return landedOn;
      }

      function updatePlayer(dt) {
        // Queue jump (buffer)
        if (keys.has("Space") || keys.has("ArrowUp")) {
          player.jumpQueued = physics.jumpBuffer;
        } else {
          player.jumpQueued = Math.max(0, player.jumpQueued - dt);
        }

        // Movement
        const left = keys.has("ArrowLeft");
        const right = keys.has("ArrowRight");
        if (left) { player.vx -= physics.moveAcc * dt; player.facing = -1; }
        if (right) { player.vx += physics.moveAcc * dt; player.facing = 1; }
        player.vx = clamp(player.vx, -physics.maxSpeed, physics.maxSpeed);

        // Gravity
        player.vy += physics.gravity * dt;

        // Friction
        if (player.onGround) player.vx *= Math.pow(physics.frictionGround, dt * 60);
        else player.vx *= Math.pow(physics.frictionAir, dt * 60);

        // Coyote time
        if (player.onGround) player.coyote = physics.coyoteTime;
        else player.coyote = Math.max(0, player.coyote - dt);

        // Apply jump if queued and allowed (ground or coyote)
        if (player.jumpQueued > 0 && player.coyote > 0) {
          player.vy = -physics.jumpVel;
          player.onGround = false;
          player.coyote = 0;
          player.jumpQueued = 0;
          AudioEngine.playJump();
        }

        // Update invulnerability timer
        player.invuln = Math.max(0, player.invuln - dt);

        // Combine static + moving platforms for collision resolution
        const allPlatforms = world.platforms.concat(world.movingPlatforms);

        // Horizontal step
        player.x += player.vx * dt;
        player.x = clamp(player.x, 0, world.width - player.w);
        resolvePlatformsX(player, allPlatforms);

        // Vertical step
        player.y += player.vy * dt;
        player.onGround = false;

        const landedOn = resolvePlatformsY(player, allPlatforms);

        // Ride moving platform (if landed on one)
        if (landedOn && world.movingPlatforms.includes(landedOn)) {
          player.x += landedOn.dx;
          player.y += landedOn.dy;
        }

        // Fell out of the world
        if (player.y > world.height + 250) {
          loseLife("Fell off the map.");
        }
      }

      // ==========================
      // ENEMIES
      // ==========================
      function updateEnemies(dt) {
        for (const e of world.enemies) {
          if (!e.alive) continue;

          e.x += e.vx * dt;
          if (e.x < e.minX) { e.x = e.minX; e.vx *= -1; }
          if (e.x + e.w > e.maxX) { e.x = e.maxX - e.w; e.vx *= -1; }

          // keep enemies on ground by simple snap to ground platform (assumes ground exists)
          // (optional: more complex nav; this is stable and clean)
          e.y = 450; // Aligned with ground top (500) - enemy h (50)
        }
      }

      function handleEnemyCollisions() {
        for (const e of world.enemies) {
          if (!e.alive) continue;

          if (!aabb(player, e)) continue;

          // If player is falling and hits top of enemy -> stomp
          const playerBottom = player.y + player.h;
          const enemyTop = e.y;

          const stomp = player.vy > 50 && (playerBottom - enemyTop) < 18;

          if (stomp) {
            e.alive = false;
            score += 100; // Mario Goomba score
            UI.score.textContent = fmtScore(score);
            player.vy = -physics.jumpVel * 0.60; // bounce
            AudioEngine.playStomp();
          } else {
            // Player gets hit (unless invulnerable)
            if (player.invuln <= 0) {
              loseLife("Hit by an enemy.");
            }
          }
        }
      }

      // ==========================
      // COINS, CHECKPOINT, GOAL, SPIKES
      // ==========================
      function handlePickupsAndHazards() {
        // Coins
        for (const c of world.coins) {
          if (!c.taken && aabb(player, c)) {
            c.taken = true;
            score += 200;
            coinsCollected++;
            UI.score.textContent = fmtScore(score);
            UI.coins.textContent = coinsCollected;
            AudioEngine.playCoin();
          }
        }

        // Spikes
        for (const s of world.spikes) {
          if (aabb(player, s)) {
            if (player.invuln <= 0) {
              loseLife("Touched spikes.");
            }
            return;
          }
        }

        // Checkpoint: set respawn
        if (aabb(player, world.checkpoint)) {
          world.respawn.x = world.checkpoint.x;
          world.respawn.y = world.checkpoint.y - 70; // spawn slightly above
        }

        // Goal: finish level
        if (aabb(player, world.goal)) {
          // Time bonus
          const bonus = Math.floor(world.timeLeft) * 50;
          score += bonus;

          const next = currentLevelIndex + 1;
          const unlocked = getUnlocked();
          if (next + 1 > unlocked && next < levels.length) {
            setUnlocked(next + 1);
          }

          // update high score
          const high = getHigh();
          if (score > high) setHigh(score);
          UI.high.textContent = getHigh();

          if (next < levels.length) {
            AudioEngine.playWin();
            showMessage(
              "Level Complete!",
              `Score: ${fmtScore(score)} (incl. ${bonus} time bonus).`,
              "Next Level",
              () => { paused = false; state = "playing"; loadLevel(next); last = performance.now(); AudioEngine.start(); },
              "Menu",
              () => showMenu()
            );
          } else {
            AudioEngine.playWin();
            showMessage(
              "All Levels Complete!",
              `Final score: ${fmtScore(score)} (incl. ${bonus} bonus).`,
              "Play Again",
              () => startGame(0),
              "Menu",
              () => showMenu()
            );
          }
        }
      }

      // ==========================
      // CAMERA
      // ==========================
      const zoom = 1.6;
      function updateCamera() {
        const viewW = canvas.width / zoom;
        const viewH = canvas.height / zoom;

        const targetX = player.x + player.w / 2 - viewW / 2;
        const targetY = player.y + player.h / 2 - viewH / 2;

        cameraX = lerp(cameraX, clamp(targetX, 0, world.width - viewW), 0.12);
        cameraY = lerp(cameraY, clamp(targetY, 0, world.height - viewH), 0.12);
      }

      // ==========================
      // RENDER
      // ==========================
      function draw() {
        // background
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!world) {
          // Draw a simple loading or title screen on canvas if needed
          ctx.fillStyle = "white";
          ctx.font = "30px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Super Mario Platformer", canvas.width / 2, canvas.height / 2);
          return;
        }

        // Parallax stars/stripes - changed to sky blue gradient feel
        ctx.save();
        ctx.globalAlpha = 0.20;
        ctx.fillStyle = "#87CEEB"; // Sky Blue
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "rgba(255,255,255,0.3)";
        for (let i = 0; i < 18; i++) {
          const x = (i * 180 - (cameraX * 0.1) % 180);
          ctx.beginPath();
          ctx.arc(x, 100 + (i % 3) * 50, 40, 0, Math.PI * 2); // Simple clouds
          ctx.fill();
        }
        ctx.restore();

        // Translate to camera
        ctx.save();
        ctx.scale(zoom, zoom);
        ctx.translate(-cameraX, -cameraY);

        // Platforms (static) - rendered as bricks
        for (const p of world.platforms) {
          ctx.fillStyle = "#A52A2A"; // Brown/Brick
          roundedRect(p.x, p.y, p.w, p.h, 4);
          ctx.fill();

          // Brick texture lines
          ctx.strokeStyle = "rgba(0,0,0,0.3)";
          ctx.lineWidth = 1;
          for (let bx = 0; bx < p.w; bx += 20) {
            ctx.beginPath();
            ctx.moveTo(p.x + bx, p.y);
            ctx.lineTo(p.x + bx, p.y + p.h);
            ctx.stroke();
          }
        }

        // Moving platforms
        for (const p of world.movingPlatforms) {
          ctx.fillStyle = "rgba(255, 122, 0, 0.22)";
          roundedRect(p.x, p.y, p.w, p.h, 10);
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 122, 0, 0.35)";
          ctx.stroke();
        }

        // Thorns (Spikes) - Metallic Sharp Look
        for (const s of world.spikes) {
          ctx.save();
          const grad = ctx.createLinearGradient(s.x, s.y, s.x, s.y + s.h);
          grad.addColorStop(0, "#444");
          grad.addColorStop(0.5, "#999");
          grad.addColorStop(1, "#222");
          ctx.fillStyle = grad;
          ctx.fillRect(s.x, s.y + s.h - 5, s.w, 5); // Base

          const teethCount = Math.floor(s.w / 12);
          const toothW = s.w / teethCount;
          for (let i = 0; i < teethCount; i++) {
            const tx = s.x + i * toothW;
            ctx.beginPath();
            ctx.moveTo(tx, s.y + s.h);
            ctx.lineTo(tx + toothW / 2, s.y);
            ctx.lineTo(tx + toothW, s.y + s.h);
            ctx.closePath();

            const toothGrad = ctx.createLinearGradient(tx, s.y, tx + toothW, s.y);
            toothGrad.addColorStop(0, "#888");
            toothGrad.addColorStop(0.5, "#fff");
            toothGrad.addColorStop(1, "#444");
            ctx.fillStyle = toothGrad;
            ctx.fill();

            ctx.strokeStyle = "rgba(0,0,0,0.3)";
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
          ctx.restore();
        }

        // Coins - Rotating 3D effect
        const coinTime = performance.now() / 200;
        for (const c of world.coins) {
          if (c.taken) continue;
          const cx = c.x + c.w / 2, cy = c.y + c.h / 2;
          const rot = Math.abs(Math.sin(coinTime)); // Fake rotation width

          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(rot, 1);

          // Coin body
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          const cGrad = ctx.createRadialGradient(-3, -3, 2, 0, 0, 10);
          cGrad.addColorStop(0, "#fff700");
          cGrad.addColorStop(1, "#ff8800");
          ctx.fillStyle = cGrad;
          ctx.fill();

          // Inner detail
          ctx.strokeStyle = "rgba(0,0,0,0.2)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, 7, 0, Math.PI * 2);
          ctx.stroke();

          // Vertical line detail
          ctx.fillStyle = "rgba(0,0,0,0.2)";
          ctx.fillRect(-1, -5, 2, 10);

          ctx.restore();

          // Glow
          ctx.shadowBlur = 10;
          ctx.shadowColor = "rgba(255, 230, 0, 0.5)";
        }
        ctx.shadowBlur = 0;

        // Checkpoint marker
        {
          const cp = world.checkpoint;
          // pole
          ctx.fillStyle = "rgba(255,255,255,0.18)";
          roundedRect(cp.x + 14, cp.y - 20, 6, cp.h + 20, 6);
          ctx.fill();

          // flag body indicates active if respawn equals checkpoint
          const active = (Math.abs(world.respawn.x - cp.x) < 1);
          ctx.fillStyle = active ? "rgba(45,227,140,0.95)" : "rgba(255,255,255,0.40)";
          roundedRect(cp.x + 20, cp.y - 10, 28, 18, 6);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.25)";
          ctx.stroke();
        }

        // Goal - Mario Pipe
        {
          const g = world.goal;
          ctx.save();

          // Pipe Body
          const pGrad = ctx.createLinearGradient(g.x, g.y, g.x + g.w, g.y);
          pGrad.addColorStop(0, "#006400");
          pGrad.addColorStop(0.3, "#32CD32");
          pGrad.addColorStop(0.5, "#90EE90");
          pGrad.addColorStop(0.7, "#32CD32");
          pGrad.addColorStop(1, "#006400");

          ctx.fillStyle = pGrad;
          ctx.fillRect(g.x + 5, g.y + 15, g.w - 10, g.h - 15);
          ctx.strokeStyle = "rgba(0,0,0,0.4)";
          ctx.strokeRect(g.x + 5, g.y + 15, g.w - 10, g.h - 15);

          // Pipe Top (Lip)
          ctx.fillStyle = pGrad;
          ctx.fillRect(g.x, g.y, g.w, 15);
          ctx.strokeRect(g.x, g.y, g.w, 15);

          // Inner Darkness (The hole)
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(g.x + 4, g.y + 2, g.w - 8, 4);

          // Glow from the pipe
          const glow = Math.sin(performance.now() / 300) * 10 + 20;
          ctx.shadowBlur = glow;
          ctx.shadowColor = "#32CD32";
          ctx.strokeStyle = "rgba(50, 205, 50, 0.5)";
          ctx.lineWidth = 2;
          ctx.strokeRect(g.x, g.y, g.w, 15);

          ctx.restore();
        }

        // Enemies
        for (const e of world.enemies) {
          if (!e.alive) continue;
          if (enemyImgReady) {
            ctx.save();
            ctx.translate(e.x + e.w / 2, e.y + e.h / 2);
            ctx.scale(e.vx > 0 ? 1 : -1, 1);
            ctx.drawImage(enemyImg, -e.w / 2, -e.h / 2, e.w, e.h);
            ctx.restore();
          } else {
            ctx.fillStyle = "brown";
            roundedRect(e.x, e.y, e.w, e.h, 4);
            ctx.fill();
          }
        }

        // Player (MATLAB icon)
        if (imgReady) {
          ctx.save();
          // flicker when invulnerable
          if (player.invuln > 0) ctx.globalAlpha = 0.5 + 0.5 * Math.sin(performance.now() / 60);

          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.scale(player.facing, 1);
          ctx.drawImage(playerImg, -player.w / 2, -player.h / 2, player.w, player.h);
          ctx.restore();
        } else {
          // fallback
          ctx.fillStyle = "#ff7a00";
          ctx.beginPath();
          ctx.moveTo(player.x + player.w / 2, player.y);
          ctx.lineTo(player.x + player.w, player.y + player.h / 2);
          ctx.lineTo(player.x + player.w / 2, player.y + player.h);
          ctx.lineTo(player.x, player.y + player.h / 2);
          ctx.closePath();
          ctx.fill();
        }

        ctx.restore();

        // subtle vignette
        ctx.save();
        ctx.globalAlpha = 0.25;
        const grad = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 80, canvas.width / 2, canvas.height / 2, 500);
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(1, "rgba(0,0,0,0.55)");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      // ==========================
      // UPDATE LOOP
      // ==========================
      function update(dt) {
        if (!world) return;

        updateMovingPlatforms(dt);
        updatePlayer(dt);
        updateEnemies(dt);
        handleEnemyCollisions();
        handlePickupsAndHazards();
        updateCamera();

        // Timer
        world.timeLeft -= dt * 2.5; // Count down approx 2.5x speed for urgency
        UI.time.textContent = Math.max(0, Math.floor(world.timeLeft));
        if (world.timeLeft <= 0) {
          loseLife("Time's up!");
        }

        // keep high updated (optional)
        const high = getHigh();
        if (score > high) { setHigh(Math.floor(score)); UI.high.textContent = fmtScore(score); }
      }

      let last = performance.now();
      function loop(t) {
        const dt = Math.min(0.033, (t - last) / 1000);
        last = t;

        if (state === "playing" && !paused && world) {
          update(dt);
          AudioEngine.update(dt);
        }
        draw();
        requestAnimationFrame(loop);
      }

      // ==========================
      // INIT
      // ==========================
      UI.high.textContent = getHigh();

      // Start with menu shown
      showMenu();

      // Menu default start if user wants quick play:
      // (Uncomment to autostart level 1)
      // startGame(0);

      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>